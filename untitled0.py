# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QHFQGABXS6nJpz4BsmGPFAmYgCe9JwnS
"""

import os
os.makedirs('plots', exist_ok=True)

!pip install prophet
import pandas as pd
from prophet import Prophet
from prophet.diagnostics import cross_validation, performance_metrics
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Load the dataset
file_path = '/content/sales_data_sample.csv'  # Update with your actual file path
sales_data = pd.read_csv(file_path, encoding='ISO-8859-1')

# Data preprocessing
sales_data['ORDERDATE'] = pd.to_datetime(sales_data['ORDERDATE'], errors='coerce')
sales_data = sales_data.dropna(subset=['ORDERDATE', 'SALES'])

# Aggregate sales by date and additional features
sales_data = sales_data.groupby(['ORDERDATE', 'PRODUCTLINE', 'YEAR_ID', 'MONTH_ID', 'QTR_ID'])['SALES'].sum().reset_index()
sales_data.columns = ['ds', 'PRODUCTLINE', 'YEAR_ID', 'MONTH_ID', 'QTR_ID', 'y']  # Prophet requires 'ds' and 'y'

# Product-wise forecasting and evaluation
results = []
overall_actual = []
overall_predicted = []

for product in sales_data['PRODUCTLINE'].unique():
    print(f"Training model for {product}...")
    product_data = sales_data[sales_data['PRODUCTLINE'] == product]

    # Fine-tuning Classic Cars
    if product == 'Classic Cars':
        model = Prophet(yearly_seasonality=True, weekly_seasonality=True, daily_seasonality=False)
        model.add_seasonality(name='quarterly', period=91.25, fourier_order=10)
    else:
        model = Prophet(yearly_seasonality=True, weekly_seasonality=True, daily_seasonality=False)
        model.add_seasonality(name='quarterly', period=91.25, fourier_order=8)

    model.add_regressor('YEAR_ID')
    model.add_regressor('MONTH_ID')
    model.add_regressor('QTR_ID')

    model.fit(product_data)

    # Cross-validation with adjusted parameters
    print(f"Cross-validating model for {product}...")

    # Calculate initial and horizon based on data size
    total_days = (product_data['ds'].max() - product_data['ds'].min()).days
    initial_days = int(total_days * 0.6)  # Use 60% of data for initial training
    horizon_days = int(total_days * 0.2)  # Use 20% of data for horizon

    initial = str(initial_days) + ' days'
    horizon = str(horizon_days) + ' days'

    cv_results = cross_validation(model, initial=initial, period='180 days', horizon=horizon)
    performance = performance_metrics(cv_results)
    print(performance[['mae', 'mse', 'rmse']].mean())

    # Create future dataframe
    future = model.make_future_dataframe(periods=365)
    future['YEAR_ID'] = future['ds'].dt.year
    future['MONTH_ID'] = future['ds'].dt.month
    future['QTR_ID'] = (future['MONTH_ID'] - 1) // 3 + 1

    forecast = model.predict(future)

    # Plot forecast
    fig = model.plot(forecast)
    plt.title(f'Sales Forecast for {product}')
    plt.show()

    # Plot components (trend, weekly, yearly, quarterly)
    fig2 = model.plot_components(forecast)
    plt.title(f'Seasonality Components for {product}')
    plt.show()

    # Evaluate forecast accuracy using multiple metrics
    actual = product_data['y']
    predicted = forecast['yhat'][:len(actual)]

    mae = mean_absolute_error(actual, predicted)
    mse = mean_squared_error(actual, predicted)
    rmse = np.sqrt(mse)
    r2 = r2_score(actual, predicted)  # Calculate R-squared

    results.append({'Product': product, 'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'R-squared': r2})
    overall_actual.extend(actual)
    overall_predicted.extend(predicted)

# Results DataFrame
results_df = pd.DataFrame(results)
print(results_df)

# Calculate overall accuracy
overall_mae = mean_absolute_error(overall_actual, overall_predicted)
overall_mse = mean_squared_error(overall_actual, overall_predicted)
overall_rmse = np.sqrt(overall_mse)

# Print overall accuracy with R-squared
print(f'Overall MAE: {overall_mae}')
print(f'Overall MSE: {overall_mse}')
print(f'Overall RMSE: {overall_rmse}')
print(f'Overall R-squared: {r2_score(overall_actual, overall_predicted)}')

# Plot error distribution
plt.figure(figsize=(12, 6))
sns.barplot(data=results_df, x='Product', y='RMSE')
plt.title('RMSE by Product Line')
plt.xticks(rotation=45)
plt.show()

# Residual Plot
residuals = pd.DataFrame({'Actual': overall_actual, 'Predicted': overall_predicted})
residuals['Residuals'] = residuals['Actual'] - residuals['Predicted']
plt.figure(figsize=(10, 6))
sns.histplot(residuals['Residuals'], kde=True, color='purple')
plt.title('Residuals Distribution')
plt.show()

import pandas as pd
from prophet import Prophet
from prophet.diagnostics import cross_validation, performance_metrics
import matplotlib.pyplot as plt
import seaborn as sns

# Load the dataset
file_path = '/content/sales_data_sample.csv'
sales_data = pd.read_csv(file_path, encoding='ISO-8859-1')

# Data preprocessing
sales_data['ORDERDATE'] = pd.to_datetime(sales_data['ORDERDATE'], errors='coerce')
sales_data = sales_data.dropna(subset=['ORDERDATE', 'SALES'])

# Aggregate sales by date and additional features
sales_data = sales_data.groupby(['ORDERDATE', 'PRODUCTLINE', 'YEAR_ID', 'MONTH_ID', 'QTR_ID'])['SALES'].sum().reset_index()
sales_data.columns = ['ds', 'PRODUCTLINE', 'YEAR_ID', 'MONTH_ID', 'QTR_ID', 'y']  # Prophet requires 'ds' and 'y'

# Product-wise forecasting and evaluation
results = []
overall_actual = []
overall_predicted = []

for product in sales_data['PRODUCTLINE'].unique():
    print(f"Training model for {product}...")
    product_data = sales_data[sales_data['PRODUCTLINE'] == product]

    # Fine-tuning different product lines
    if product == 'Classic Cars':
        model = Prophet(yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False)
        model.add_seasonality(name='quarterly', period=91.25, fourier_order=12)
    elif product == 'Motorcycles':
        model = Prophet(yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False)
        model.add_seasonality(name='quarterly', period=91.25, fourier_order=10)
    elif product == 'Trucks and Buses':
        model = Prophet(yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False)
        model.add_seasonality(name='quarterly', period=91.25, fourier_order=8)
    else:
        model = Prophet(yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False)
        model.add_seasonality(name='quarterly', period=91.25, fourier_order=6)

    model.add_regressor('YEAR_ID')
    model.add_regressor('MONTH_ID')
    model.add_regressor('QTR_ID')

    model.fit(product_data)

    # Cross-validation with adjusted initial and horizon
    print(f"Cross-validating model for {product}...")

    # Calculate initial and horizon based on data size to avoid the error
    total_days = (product_data['ds'].max() - product_data['ds'].min()).days
    initial_days = int(total_days * 0.6)  # Use 60% of data for initial training
    horizon_days = int(total_days * 0.2)  # Use 20% of data for horizon
    # Ensure horizon is less than the remaining data after the initial period
    horizon_days = min(horizon_days, total_days - initial_days - 1)

    initial = str(initial_days) + ' days'
    horizon = str(horizon_days) + ' days'

    cv_results = cross_validation(model, initial=initial, period='180 days', horizon=horizon)
    performance = performance_metrics(cv_results)
    print(performance[['mae', 'mse', 'rmse']].mean())

    # Create future dataframe
    future = model.make_future_dataframe(periods=365)
    future['YEAR_ID'] = future['ds'].dt.year
    future['MONTH_ID'] = future['ds'].dt.month
    future['QTR_ID'] = (future['MONTH_ID'] - 1) // 3 + 1

    forecast = model.predict(future)

    # Plot forecast
    fig = model.plot(forecast)
    plt.title(f'Sales Forecast for {product}')
    plt.savefig('plots/forecasting.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Plot components (trend, weekly, yearly, quarterly)
    fig2 = model.plot_components(forecast)
    plt.title(f'Seasonality Components for {product}')
    plt.savefig('plots/components.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Evaluate forecast accuracy
    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
    import numpy as np

    actual = product_data['y']
    predicted = forecast['yhat'][:len(actual)]
    mae = mean_absolute_error(actual, predicted)
    mse = mean_squared_error(actual, predicted)
    rmse = np.sqrt(mse)
    accuracy = r2_score(actual, predicted)

    results.append({'Product': product, 'MAE': mae, 'MSE': mse, 'RMSE': rmse, 'Accuracy': accuracy})
    overall_actual.extend(actual)
    overall_predicted.extend(predicted)

# Results DataFrame
results_df = pd.DataFrame(results)
print(results_df)

# Calculate overall accuracy
overall_mae = mean_absolute_error(overall_actual, overall_predicted)
overall_mse = mean_squared_error(overall_actual, overall_predicted)
overall_rmse = np.sqrt(overall_mse)
overall_accuracy = r2_score(overall_actual, overall_predicted)

print(f'Overall MAE: {overall_mae}')
print(f'Overall MSE: {overall_mse}')
print(f'Overall RMSE: {overall_rmse}')
print(f'Overall Accuracy: {overall_accuracy}')

# Plot error distribution
plt.figure(figsize=(12, 6))
sns.barplot(data=results_df, x='Product', y='RMSE')
plt.title('RMSE by Product Line')
plt.xticks(rotation=45)
plt.show()

# Residual Plot
residuals = pd.DataFrame({'Actual': overall_actual, 'Predicted': overall_predicted})
residuals['Residuals'] = residuals['Actual'] - residuals['Predicted']
plt.figure(figsize=(10, 6))
sns.histplot(residuals['Residuals'], kde=True, color='purple')
plt.title('Residuals Distribution')
plt.savefig('plots/residual.png', dpi=300, bbox_inches='tight')
plt.show()

import shutil

# Create a zip file of the 'plots' directory
shutil.make_archive('/mnt/data/plots', 'zip', 'plots')

print("Plots folder has been zipped and is ready for download.")

import shutil
from google.colab import files

# Zip the 'plots' folder
shutil.make_archive('/content/plots', 'zip', '/content/plots')

# Download the zip file
files.download('/content/plots.zip')

